# -*- coding: utf-8 -*-
"""Cópia de HEURISTICA MOSAICO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UHECysg-1hfX_tOnp1LAcXZdKRZv4Nc6
"""

##ESTRATEGIA DO MAIOR AO MENOR
import matplotlib.pyplot as plt
import random
import math
import time

random.seed(4)

# Definir las instâncias de círculos
instancias_circulos = [
    [{"raio": 1}, {"raio": 2}, {"raio": 3}, {"raio": 4}, {"raio": 5}, {"raio": 6}, {"raio": 7}],
    [{"raio": 1} for _ in range(5)] + [{"raio": 2} for _ in range(5)] + [{"raio": 3} for _ in range(5)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)]  + [{"raio": 4} for _ in range(10)] + [{"raio": 5} for _ in range(10)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)]  + [{"raio": 4} for _ in range(10)] + [{"raio": 5} for _ in range(10)] + [{"raio": 6} for _ in range(10)] + [{"raio": 7} for _ in range(10)] + [{"raio": 8} for _ in range(10)]  + [{"raio": 9} for _ in range(10)] + [{"raio": 10} for _ in range(10)]
]

# Converter instâncias de círculos em instâncias de quadrados
instancias_quadrados = []

for instancia_circulo in instancias_circulos:
    instancia_quadrado = [{"lado": 2 * circulo["raio"]} for circulo in instancia_circulo]
    instancias_quadrados.append(instancia_quadrado)


# Função para verificar se um quadrado se sobrepõe com outros em uma lista de quadrados
def se_sobrepoe(quadrado, quadrados_em_contenedor):
    for q in quadrados_em_contenedor:
        distancia_centros_x = abs(quadrado["x"] - q["x"])
        distancia_centros_y = abs(quadrado["y"] - q["y"])
        metade_soma_lados = (quadrado["lado"] + q["lado"]) / 2
        if distancia_centros_x <= metade_soma_lados and distancia_centros_y <= metade_soma_lados:
            return True
    return False

def encontrar_posicao(quadrado, quadrados_em_contenedor, raio_contenedor, posicao_central):
    intentos = 0
    while intentos < 5900:
        if not quadrados_em_contenedor:
            angulo = 0
        else:
            angulo = random.uniform(0, 2 * math.pi)


        distancia = raio_contenedor/2

        quadrado["x"] = posicao_central[0] + distancia * math.cos(angulo)
        quadrado["y"] = posicao_central[1] + distancia * math.sin(angulo)
        if not se_sobrepoe(quadrado, quadrados_em_contenedor):
            return True

        intentos += 1

    return False

# Função principal para resolver el PECD e visualizar a solução para cada instância
def resolver_quadrados():
    for i, instancia_quadrados in enumerate(instancias_quadrados):

        quadrados_em_contenedor = []
        posicao_central_desejada = (0, 0)

        instancia_quadrados = sorted(instancia_quadrados, key=lambda x: -x["lado"])

        # Calcular o raio do contêiner
        raio_contenedor = max(quadrado["lado"] / 2 for quadrado in instancia_quadrados)

        # Medir o tempo de execução
        start_time = time.time()

        # Colocar os quadrados no contêiner
        for quadrado in instancia_quadrados:
            while not encontrar_posicao(quadrado, quadrados_em_contenedor, raio_contenedor, posicao_central_desejada):
                raio_contenedor += quadrado["lado"] / 10

            quadrados_em_contenedor.append(quadrado)

        # Calcular o novo centro como a média das coordenadas dos quadrados posicionados
        novo_centro_x = sum(quadrado["x"] for quadrado in quadrados_em_contenedor) / len(quadrados_em_contenedor)
        novo_centro_y = sum(quadrado["y"] for quadrado in quadrados_em_contenedor) / len(quadrados_em_contenedor)

        # Calcular o novo raio como a maior distância entre um quadrado e o novo centro mais seu raio
        novo_raio = max(
            math.sqrt((quadrado["x"] - novo_centro_x)**2 + (quadrado["y"] - novo_centro_y)**2) + quadrado["lado"] / 2
            for quadrado in quadrados_em_contenedor
        )

        # Calcular o tempo de execução
        end_time = time.time()
        tempo_execucao = end_time - start_time

        # Configurar a figura e o eixo
        fig, ax = plt.subplots(figsize=(7, 7))

        # Desenhar o contêiner circular
        contenedor = plt.Circle((novo_centro_x, novo_centro_y), novo_raio, fill=False, color='b', lw=0.5)
        ax.add_patch(contenedor)

        # Desenhar os quadrados no contêiner e círculos inscritos
        for quadrado in quadrados_em_contenedor:
            x = quadrado["x"]
            y = quadrado["y"]
            lado = quadrado["lado"]
            meio_lado = lado / 2
            quadrado_desenho = plt.Rectangle((x - meio_lado, y - meio_lado), lado, lado, fill=False, color='r', lw=0.5)
            ax.add_patch(quadrado_desenho)

            # Calcular o raio do círculo inscrito
            raio_circulo_inscrito = lado / 2

            # Desenhar o círculo inscrito
            circulo_inscrito = plt.Circle((x, y), raio_circulo_inscrito, fill=False, color='g', lw=0.5)
            ax.add_patch(circulo_inscrito)

        ax.set_aspect('equal')
        ax.set_xlim(novo_centro_x - novo_raio, novo_centro_x + novo_raio)
        ax.set_ylim(novo_centro_y - novo_raio, novo_centro_y + novo_raio)

        # Adicionar o título ao gráfico com o nome da instância e o tempo de execução
        titulo = f'Instância {i+1}\nRaio do Contêiner = {novo_raio:.2f}\nTempo de Execução = {tempo_execucao:.2f} segundos'
        plt.title(titulo)
        plt.gca().set_aspect('equal', adjustable='box')
        # plt.axis('off')
        plt.grid()

        # Salvar a imagem com o nome da instância
        nome_arquivo = f'MOSAICO MAIOR MENOR {i+1}.png'
        plt.savefig(nome_arquivo, dpi=100)
        plt.show()

# Chamar a função principal para resolver e salvar as instâncias de quadrados
resolver_quadrados()

import matplotlib.pyplot as plt
import random
import math
import time

random.seed(4)

# Definir as instâncias de círculos
instancias_circulos = [
    [{"raio": 1}, {"raio": 2}, {"raio": 3}, {"raio": 4}, {"raio": 5}, {"raio": 6}, {"raio": 7}],
    [{"raio": 1} for _ in range(5)] + [{"raio": 2} for _ in range(5)] + [{"raio": 3} for _ in range(5)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)]  + [{"raio": 4} for _ in range(10)] + [{"raio": 5} for _ in range(10)],
    [{"raio": 1} for _ in range(10)] + [{"raio": 2} for _ in range(10)] + [{"raio": 3} for _ in range(10)]  + [{"raio": 4} for _ in range(10)] + [{"raio": 5} for _ in range(10)] + [{"raio": 6} for _ in range(10)] + [{"raio": 7} for _ in range(10)] + [{"raio": 8} for _ in range(10)]  + [{"raio": 9} for _ in range(10)] + [{"raio": 10} for _ in range(10)]
]

# Converter instâncias de círculos em instâncias de quadrados
instancias_quadrados = []

for instancia_circulo in instancias_circulos:
    instancia_quadrado = [{"lado": 2 * circulo["raio"]} for circulo in instancia_circulo]
    instancias_quadrados.append(instancia_quadrado)


# Função para verificar se um quadrado se sobrepõe com outros em uma lista de quadrados
def se_sobrepoe(quadrado, quadrados_em_contenedor):
    for q in quadrados_em_contenedor:
        distancia_centros_x = abs(quadrado["x"] - q["x"])
        distancia_centros_y = abs(quadrado["y"] - q["y"])
        metade_soma_lados = (quadrado["lado"] + q["lado"]) / 2
        if distancia_centros_x <= metade_soma_lados and distancia_centros_y <= metade_soma_lados:
            return True
    return False

def encontrar_posicao(quadrado, quadrados_em_contenedor, raio_contenedor, posicao_central):
    intentos = 0
    while intentos < 5900:
        if not quadrados_em_contenedor:
            angulo = 0
        else:
            angulo = random.uniform(0, 2 * math.pi)


        distancia = raio_contenedor/2

        quadrado["x"] = posicao_central[0] + distancia * math.cos(angulo)
        quadrado["y"] = posicao_central[1] + distancia * math.sin(angulo)
        if not se_sobrepoe(quadrado, quadrados_em_contenedor):
            return True

        intentos += 1

    return False

# Função principal para resolver e salvar as instâncias de quadrados
def resolver_quadrados(instancia_quadrados):
    for i, instancia_quadrados in enumerate(instancia_quadrados):
        quadrados_em_contenedor = []
        posicao_central_desejada = (0, 0)
        instancia_quadrados = sorted(instancia_quadrados, key=lambda x: -x["lado"])
        raio_contenedor = max(quadrado["lado"] / 2 for quadrado in instancia_quadrados)
        start_time = time.time()

        # Implementação do GRASP
        num_iteracoes_grasp = 200
        melhor_solucao = None

        for _ in range(num_iteracoes_grasp):
            solucao_inicial = construcao_aleatoria(instancia_quadrados)
            solucao_atual = busca_local(solucao_inicial)

            # Calcula a função objetivo para a solução atual
            objetivo_atual = calcula_funcao_objetivo(solucao_atual)

            if melhor_solucao is None or objetivo_atual < calcula_funcao_objetivo(melhor_solucao):
                melhor_solucao = solucao_atual

        # Fim do GRASP

        novo_centro_x = sum(quadrado["x"] for quadrado in melhor_solucao) / len(melhor_solucao)
        novo_centro_y = sum(quadrado["y"] for quadrado in melhor_solucao) / len(melhor_solucao)

        novo_raio = max(
            math.sqrt((quadrado["x"] - novo_centro_x)**2 + (quadrado["y"] - novo_centro_y)**2) + quadrado["lado"] / 2
            for quadrado in melhor_solucao
        )

        end_time = time.time()
        tempo_execucao = end_time - start_time

        fig, ax = plt.subplots(figsize=(7, 7))
        contenedor = plt.Circle((novo_centro_x, novo_centro_y), novo_raio, fill=False, color='b', lw=0.5)
        ax.add_patch(contenedor)

        for quadrado in melhor_solucao:
            x = quadrado["x"]
            y = quadrado["y"]
            lado = quadrado["lado"]
            meio_lado = lado / 2
            quadrado_desenho = plt.Rectangle((x - meio_lado, y - meio_lado), lado, lado, fill=False, color='r', lw=0.5)
            ax.add_patch(quadrado_desenho)
            raio_circulo_inscrito = lado / 2
            circulo_inscrito = plt.Circle((x, y), raio_circulo_inscrito, fill=False, color='g', lw=0.5)
            ax.add_patch(circulo_inscrito)

        ax.set_aspect('equal')
        ax.set_xlim(novo_centro_x - novo_raio, novo_centro_x + novo_raio)
        ax.set_ylim(novo_centro_y - novo_raio, novo_centro_y + novo_raio)

        titulo = f'Instância {i+1}\nRaio do Contêiner = {novo_raio:.2f}\nTempo de Execução = {tempo_execucao:.2f} segundos'
        plt.title(titulo)
        plt.gca().set_aspect('equal', adjustable='box')
        plt.grid()

        nome_arquivo = f'MOSAICO_GRASP_{i+1}.png'
        plt.savefig(nome_arquivo, dpi=100)
        plt.show()

# Função de Construção Aleatória
def construcao_aleatoria(instancia_quadrados):
    quadrados_em_contenedor = []
    random.shuffle(instancia_quadrados)
    raio_contenedor = max(quadrado["lado"] / 2 for quadrado in instancia_quadrados)

    posicao_central_desejada = (0, 0)

    for quadrado in instancia_quadrados:
        while not encontrar_posicao(quadrado, quadrados_em_contenedor, raio_contenedor, posicao_central_desejada):
            raio_contenedor += quadrado["lado"] / 10
        quadrados_em_contenedor.append(quadrado)

    return quadrados_em_contenedor


# Função de Melhoria (Local Search)
def busca_local(quadrados_em_contenedor):
    melhor_solucao = quadrados_em_contenedor.copy()

    for i in range(len(quadrados_em_contenedor)):
        for j in range(i+1, len(quadrados_em_contenedor)):
            # Tente trocar a posição de dois quadrados e verifique se melhora a solução
            quadrados_em_contenedor[i], quadrados_em_contenedor[j] = quadrados_em_contenedor[j], quadrados_em_contenedor[i]

            if not se_sobrepoe(quadrados_em_contenedor[i], quadrados_em_contenedor[:i]) and not se_sobrepoe(quadrados_em_contenedor[j], quadrados_em_contenedor[:j]):
                # Se a troca não causar sobreposição, mantenha a mudança
                solucao_atual = quadrados_em_contenedor.copy()
                if calcula_funcao_objetivo(solucao_atual) < calcula_funcao_objetivo(melhor_solucao):
                    melhor_solucao = solucao_atual

            # Reverta a troca
            quadrados_em_contenedor[i], quadrados_em_contenedor[j] = quadrados_em_contenedor[j], quadrados_em_contenedor[i]

    return melhor_solucao

# Função para calcular a função objetivo (neste caso, a soma dos raios)
def calcula_funcao_objetivo(quadrados_em_contenedor):
    return sum(quadrado["lado"] / 2 for quadrado in quadrados_em_contenedor)

# Chame a função principal para resolver e salvar as instâncias de quadrados
resolver_quadrados(instancias_quadrados)

